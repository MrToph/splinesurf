{"ts":1344705013319,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Game.Player = new Class({\r\n    initialize: function(spline){\r\n        this.mesh = null;\r\n        this.meshGround = null;\r\n        this.meshBody = null;\r\n        this.arcLengthPos = 0.0;\r\n        this.msPerFrame = 0.005;\r\n        this.direction = 0;\r\n        this.splineRef = spline;\r\n    },\r\n    \r\n    buildMeshGrounding: function(){\r\n        \r\n    },\r\n    \r\n    buildMeshBody: function(){\r\n          \r\n    },\r\n    \r\n     moveDirection: function(dir){\r\n          \r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        this.arcLengthPos += this.msPerFrame;\r\n        //alignPlayer();     gets called in controller for performance issues, because we dont need this every tick just every repaint \r\n    },\r\n    \r\n    alignPlayer: function(){\r\n        \r\n    },\r\n    \r\n    initNextLevel: function(spline){\r\n        this.splineRef = spline;\r\n        // build new ground mesh\r\n        \r\n        // set new start position\r\n        this.arcLengthPos = 0;\r\n    }\r\n});"]],"start1":0,"start2":0,"length1":0,"length2":959}]],"length":959}
{"contributors":[],"silentsave":false,"ts":1344771059402,"patch":[[{"diffs":[[0,"e = 0.00"],[-1,""],[0,""],[1,"0"],[0,"5;\r\n    "]],"start1":209,"start2":209,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"},\r\n    \r\n    buildMeshGrounding: function(){\r\n        \r\n    },\r\n    \r\n    buildMeshBody: function(){\r\n          \r\n    },\r\n    \r\n     moveDirection: function(dir){\r\n          \r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        this.arcLengthPos += this.msPerFrame;\r\n        //alignPlayer();     gets called in controller for performance issues, because we dont need this every tick just every repaint "],[1,"    this.splineGeometry = null;\r\n        this.splineSegments = 0;\r\n        this.material = null;\r\n        this.initMaterials();\r\n        this.pos = new THREE.Vector3();\r\n    },\r\n    \r\n    buildMeshGrounding: function(){\r\n        this.splineSegmentsRadius = this.splineGeometry.segmentsRadius; // shape of the segments\r\n        this.splineRadius = this.splineGeometry.radius;                 // fatness of the spline\r\n        \r\n        this.meshGround = new THREE.Mesh(\r\n            new THREE.CylinderGeometry( this.splineRadius/*radiusTop*/, this.splineRadius/*radiusBottom*/, 0.1/*height*/, this.splineSegmentsRadius/*segmentsRadius*/, 100/*segmentsHeight*/, false/*openEnded*/ ),\r\n            this.material);\r\n    },\r\n    \r\n    buildMeshBody: function(){\r\n          \r\n    },\r\n    \r\n     moveDirection: function(dir){\r\n          var d = this.direction + dir;\r\n          if(d < 0) d += this.splineSegmentsRadius;\r\n          else if(d > this.splineSegmentsRadius - 1) d -= this.splineSegmentsRadius;\r\n          this.direction = d;\r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        this.arcLengthPos += this.msPerFrame;\r\n        if(this.arcLengthPos >= 1.0){\r\n            this.arcLengthPos -= 1;\r\n            console.log(this.splineGeometry.path.getLength());\r\n        }\r\n        this.pos = this.splineGeometry.path.getPointAt(this.arcLengthPos);\r\n    },\r\n    \r\n    alignPlayer: function(){\r\n        // rot = normale, blau = tangente, gruen = binormale\r\n        var geom = this.splineGeometry;\r\n        var i = Math.floor(this.arcLengthPos*geom.segments);\r\n        //var dir = geom.normals[i];\r\n        if(! geom.faces[i*this.splineSegmentsRadius + this.direction]){\r\n            console.log(\"Error at \"+ i + \" \" + this.arcLengthPos + \" (\" + (i*this.splineSegmentsRadius + this.direction));   \r\n        }\r\n        var dir = geom.faces[i*this.splineSegmentsRadius + this.direction].normal;\r\n        var offPos = this.pos.clone().addSelf(dir.normalize().multiplyScalar(geom.radius));\r\n        this.mesh.position.set(offPos.x, offPos.y, offPos.z);\r\n        this.mesh.lookAt(this.pos);\r\n        //this.mesh.lookAt(new THREE.Vector3());\r\n        \r\n        \r\n        // rotation\r\n        var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n        var m = new THREE.Matrix4();"],[0,"\r\n  "]],"start1":285,"start2":285,"length1":416,"length2":2321},{"diffs":[[0,"\r\n    \r\n    "],[-1,"alignPlayer"],[1,"initMaterials"],[0,": function()"]],"start1":2610,"start2":2610,"length1":35,"length2":37},{"diffs":[[0,"    "],[-1,"\r\n    },\r\n    \r\n    initNextLevel: function(spline){\r\n        this.splineRef = spline;\r\n        // build new ground mesh\r\n        \r\n        // set new start position\r\n        this.arcLengthPos = 0;\r\n    }\r\n});"],[1,"   this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n    },\r\n    \r\n    initNextLevel: function(spline){\r\n        this.splineRef = spline;\r\n        this.splineGeometry = this.splineRef.children[0].geometry;\r\n        this.splineSegments = this.splineGeometry.segments;\r\n        // build new ground mesh\r\n        this.buildMeshGrounding();\r\n        this.mesh = this.meshGround;\r\n        representation.scene.add(this.mesh);\r\n        \r\n        // set new start position\r\n        this.arcLengthPos = 0;\r\n        \r\n        // set speed per frame based on arclength\r\n        var pathLength = this.splineGeometry.path.getLength();\r\n        this.msPerFrame = 1.0/(2.5*pathLength);\r\n    }\r\n});\r\n\r\n\r\n\r\n"]],"start1":2654,"start2":2654,"length1":213,"length2":761}]],"length":3415,"saved":false}
{"ts":1344771070988,"patch":[[{"diffs":[[0,"Matrix4("],[1,"tangent, normal, binormal"],[0,");\r\n    "]],"start1":2592,"start2":2592,"length1":16,"length2":41}]],"length":3440,"saved":false}
{"ts":1344771263879,"patch":[[{"diffs":[[0,"(tangent"],[1,".x"],[0,", normal"],[1,".x"],[0,", binorm"]],"start1":2599,"start2":2599,"length1":24,"length2":28},{"diffs":[[0,"binormal"],[1,".x, 0\r\n                                    tangent.y, normal.y, binormal.y, 0\r\n                                    tangent.z, normal.z, binormal.z"],[0,");\r\n    "]],"start1":2621,"start2":2621,"length1":16,"length2":162}]],"length":3590,"saved":false}
{"ts":1344771291182,"patch":[[{"diffs":[[0,"mal.x, 0"],[1,","],[0,"\r\n      "]],"start1":2626,"start2":2626,"length1":16,"length2":17},{"diffs":[[0,"mal.y, 0"],[1,","],[0,"\r\n      "]],"start1":2699,"start2":2699,"length1":16,"length2":17}]],"length":3592,"saved":false}
{"contributors":[],"silentsave":false,"ts":1344815230387,"patch":[[{"diffs":[[1,"Game.Player = new Class({\r\n    initialize: function(spline){\r\n        this.mesh = new THREE.Object3D();\r\n        this.meshGround = null;\r\n        this.meshBody = null;\r\n        this.arcLengthPos = 0.0;\r\n        this.msPerFrame = 0.0;\r\n        this.direction = 0;\r\n        this.splineRef = spline;\r\n        this.splineGeometry = null;\r\n        this.splineSegments = 0;\r\n        this.material = null;\r\n        this.initMaterials();\r\n        this.pos = new THREE.Vector3();\r\n    },\r\n    \r\n    buildMeshGrounding: function(){\r\n        this.splineSegmentsRadius = this.splineGeometry.segmentsRadius; // shape of the segments\r\n        this.splineRadius = this.splineGeometry.radius;                 // fatness of the spline\r\n        \r\n        this.meshGround = new THREE.Mesh(\r\n            new THREE.CylinderGeometry( this.splineRadius/*radiusTop*/, this.splineRadius/*radiusBottom*/, 0.1/*height*/, this.splineSegmentsRadius/*segmentsRadius*/, 100/*segmentsHeight*/, false/*openEnded*/ ),\r\n            this.material);\r\n        this.meshGround.rotation.x = 1.5*Math.PI;\r\n        this.meshGround.rotation.z = Math.PI/2;\r\n    },\r\n    \r\n    buildMeshBody: function(){\r\n          \r\n    },\r\n    \r\n     moveDirection: function(dir){\r\n          var d = this.direction + dir;\r\n          if(d < 0) d += this.splineSegmentsRadius;\r\n          else if(d > this.splineSegmentsRadius - 1) d -= this.splineSegmentsRadius;\r\n          this.direction = d;\r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        this.arcLengthPos += this.msPerFrame;\r\n        if(this.arcLengthPos >= 1.0){\r\n            this.arcLengthPos -= 1;\r\n            console.log(this.splineGeometry.path.getLength());\r\n        }\r\n        this.pos = this.splineGeometry.path.getPointAt(this.arcLengthPos);\r\n    },\r\n    \r\n    alignPlayer: function(){\r\n        // rot = normale, blau = tangente, gruen = binormale\r\n        var geom = this.splineGeometry;\r\n        var i = Math.floor(this.arcLengthPos*geom.segments);\r\n        //var dir = geom.normals[i];\r\n        if(! geom.faces[i*this.splineSegmentsRadius + this.direction]){\r\n            console.log(\"Error at \"+ i + \" \" + this.arcLengthPos + \" (\" + (i*this.splineSegmentsRadius + this.direction));   \r\n        }\r\n        var dir = geom.faces[i*this.splineSegmentsRadius + this.direction].normal;\r\n        var offPos = this.pos.clone().addSelf(dir.normalize().multiplyScalar(1.5*geom.radius));\r\n        this.mesh.position.set(offPos.x, offPos.y, offPos.z);\r\n        //this.mesh.lookAt(this.pos);\r\n        //this.mesh.lookAt(new THREE.Vector3());\r\n        \r\n        \r\n        // rotation\r\n        var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n        var first = tangent, second = normal, third = binormal;\r\n        var m = new THREE.Matrix4(first.x, second.x, third.x, 0,\r\n                                    first.y, second.y, third.y, 0,\r\n                                    first.z, second.z, third.z);\r\n        this.mesh.rotation.getRotationFromMatrix(m);\r\n        console.log();\r\n    },\r\n    \r\n    initMaterials: function(){\r\n           this.material = new THREE.MeshPhongMaterial({color: 0xcccccc, opacity: 0.8, wireframe: false, transparent: true});\r\n    },\r\n    \r\n    initNextLevel: function(spline){\r\n        this.splineRef = spline;\r\n        this.splineGeometry = this.splineRef.children[0].geometry;\r\n        this.splineSegments = this.splineGeometry.segments;\r\n        // build new ground mesh\r\n        this.buildMeshGrounding();\r\n        this.mesh.add(this.meshGround);\r\n        representation.scene.add(this.mesh);\r\n        \r\n        // set new start position\r\n        this.arcLengthPos = 0;\r\n        \r\n        // set speed per frame based on arclength\r\n        var pathLength = this.splineGeometry.path.getLength();\r\n        this.msPerFrame = 1.0/(2.0*pathLength);\r\n    }\r\n});\r\n\r\n\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":3842}]],"length":3842,"saved":false}
{"contributors":[],"silentsave":false,"ts":1344815816397,"patch":[[{"diffs":[[0,"om.normals[i];\r\n"],[1,"        \r\n        // THIS WORKS =========\r\n//"],[0,"        if(! geo"]],"start1":1987,"start2":1987,"length1":32,"length2":77},{"diffs":[[0,"s.direction]){\r\n"],[1,"//"],[0,"            cons"]],"start1":2105,"start2":2105,"length1":32,"length2":34},{"diffs":[[0,"irection));   \r\n"],[1,"//"],[0,"        }\r\n     "]],"start1":2234,"start2":2234,"length1":32,"length2":34},{"diffs":[[0," \r\n//        }\r\n"],[1,"//"],[0,"        var dir "]],"start1":2247,"start2":2247,"length1":32,"length2":34},{"diffs":[[0,"ction].normal;\r\n"],[1,"//"],[0,"        var offP"]],"start1":2333,"start2":2333,"length1":32,"length2":34},{"diffs":[[0,"geom.radius));\r\n"],[1,"//"],[0,"        this.mes"]],"start1":2432,"start2":2432,"length1":32,"length2":34},{"diffs":[[0,"  //"],[-1,"this.mesh.lookAt(this.pos);\r\n        //this.mesh.lookAt(new THREE.Vector3());\r\n        "],[1," END WORKS ==========\r\n        \r\n        // binormal and normal make a plane (=> tangent is the normal of the plane)"],[0,"\r\n  "]],"start1":2519,"start2":2519,"length1":95,"length2":124},{"diffs":[[0,"(2.0"],[-1,"*pathLength);\r\n    }\r\n});\r\n\r\n\r\n\r\nGame.Player = new Class({\r\n    initialize: function(spline){\r\n        this.mesh = null;\r\n        this.meshGround = null;\r\n        this.meshBody = null;\r\n        this.arcLengthPos = 0.0;\r\n        this.msPerFrame = 0.0005;\r\n        this.direction = 0;\r\n        this.splineRef = spline;\r\n        this.splineGeometry = null;\r\n        this.splineSegments = 0;\r\n        this.material = null;\r\n        this.initMaterials();\r\n        this.pos = new THREE.Vector3();\r\n    },\r\n    \r\n    buildMeshGrounding: function(){\r\n        this.splineSegmentsRadius = this.splineGeometry.segmentsRadius; // shape of the segments\r\n        this.splineRadius = this.splineGeometry.radius;                 // fatness of the spline\r\n        \r\n        this.meshGround = new THREE.Mesh(\r\n            new THREE.CylinderGeometry( this.splineRadius/*radiusTop*/, this.splineRadius/*radiusBottom*/, 0.1/*height*/, this.splineSegmentsRadius/*segmentsRadius*/, 100/*segmentsHeight*/, false/*openEnded*/ ),\r\n            this.material);\r\n    },\r\n    \r\n    buildMeshBody: function(){\r\n          \r\n    },\r\n    \r\n     moveDirection: function(dir){\r\n          var d = this.direction + dir;\r\n          if(d < 0) d += this.splineSegmentsRadius;\r\n          else if(d > this.splineSegmentsRadius - 1) d -= this.splineSegmentsRadius;\r\n          this.direction = d;\r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        this.arcLengthPos += this.msPerFrame;\r\n        if(this.arcLengthPos >= 1.0){\r\n            this.arcLengthPos -= 1;\r\n            console.log(this.splineGeometry.path.getLength());\r\n        }\r\n        this.pos = this.splineGeometry.path.getPointAt(this.arcLengthPos);\r\n    },\r\n    \r\n    alignPlayer: function(){\r\n        // rot = normale, blau = tangente, gruen = binormale\r\n        var geom = this.splineGeometry;\r\n        var i = Math.floor(this.arcLengthPos*geom.segments);\r\n        //var dir = geom.normals[i];\r\n        if(! geom.faces[i*this.splineSegmentsRadius + this.direction]){\r\n            console.log(\"Error at \"+ i + \" \" + this.arcLengthPos + \" (\" + (i*this.splineSegmentsRadius + this.direction));   \r\n        }\r\n        var dir = geom.faces[i*this.splineSegmentsRadius + this.direction].normal;\r\n        var offPos = this.pos.clone().addSelf(dir.normalize().multiplyScalar(geom.radius));\r\n        this.mesh.position.set(offPos.x, offPos.y, offPos.z);\r\n        this.mesh.lookAt(this.pos);\r\n        //this.mesh.lookAt(new THREE.Vector3());\r\n        \r\n        \r\n        // rotation\r\n        var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n        var m = new THREE.Matrix4(tangent.x, normal.x, binormal.x, 0,\r\n                                    tangent.y, normal.y, binormal.y, 0,\r\n                                    tangent.z, normal.z, binormal.z);\r\n    },\r\n    \r\n    initMaterials: function(){\r\n           this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n    },\r\n    \r\n    initNextLevel: function(spline){\r\n        this.splineRef = spline;\r\n        this.splineGeometry = this.splineRef.children[0].geometry;\r\n        this.splineSegments = this.splineGeometry.segments;\r\n        // build new ground mesh\r\n        this.buildMeshGrounding();\r\n        this.mesh = this.meshGround;\r\n        representation.scene.add(this.mesh);\r\n        \r\n        // set new start position\r\n        this.arcLengthPos = 0;\r\n        \r\n        // set speed per frame based on arclength\r\n        var pathLength = this.splineGeometry.path.getLength();\r\n        this.msPerFrame = 1.0/(2.5"],[0,""],[1,""],[0,"*pat"]],"start1":3889,"start2":3889,"length1":3600,"length2":8}]],"length":3926,"saved":false}
